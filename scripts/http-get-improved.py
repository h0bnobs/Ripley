#!/usr/bin/python
# Author: Thomas Beeney
# Version: 1.1
# HTTP-GET Tool for removing false positives when auditing plaintext HTTP services

import requests
import sys
import argparse
import os
from libnmap.parser import NmapParser
import urllib3
from termcolor import colored
from utils import COLOURS

# Disable warnings from urllib3 (used by requests)
urllib3.disable_warnings()


def banner():
    banner_text = r"""
  _   _   _                     _
 | |_| |_| |_ _ __ ___ __ _ ___| |_
 | ' \  _|  _| '_ \___/ _` / -_)  _|
 |_||_\__|\__| .__/   \__, \___|\__|
             |_|      |___/
    @BeeSec
    Helping you Bee Secure

usage: http-get-improved.py -i <input file> | -x <xml file>
"""
    print(colored(f'{banner_text}', "light_blue"))


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="HTTP-GET Tool for scanning HTTP services")
    parser.add_argument("-i", "--ifile", help="Input file containing <host>:<port> entries")
    parser.add_argument("-x", "--xfile", help="XML file generated by Nmap for input")
    return parser.parse_args()


def validate_file(file_path: str) -> bool:
    """Check if the file exists and is readable."""
    return os.path.isfile(file_path) and os.access(file_path, os.R_OK)


def initialize_output_files(output_dir: str) -> dict:
    """Create output files and return their file handles."""
    os.makedirs(output_dir, exist_ok=True)
    output_files = {
        "plaintext": open(os.path.join(output_dir, "http-get-plaintext.txt"), "w+"),
        "redirect": open(os.path.join(output_dir, "http-get-redirecting.txt"), "w+"),
        "errorlog": open(os.path.join(output_dir, "http-get-errorlog.txt"), "w+"),
        "warnings": open(os.path.join(output_dir, "http-get-warnings.txt"), "w+"),
        "log": open(os.path.join(output_dir, "http-get-log.csv"), "w+")
    }
    return output_files


def close_output_files(files: dict):
    """Close all output files."""
    for file in files.values():
        file.close()


def main():
    args = parse_arguments()

    if args.xfile:
        if not validate_file(args.xfile):
            print(COLOURS["cross"] + f" Error: Invalid XML file '{args.xfile}'." + COLOURS["end"])
            sys.exit(1)
        xml_file_scanner(args.xfile)
    elif args.ifile:
        if not validate_file(args.ifile):
            print(COLOURS["cross"] + f" Error: Invalid input file '{args.ifile}'." + COLOURS["end"])
            sys.exit(1)
        txt_file_scanner(args.ifile)
    else:
        print(COLOURS[
                  "cross"] + " Error: Either the -i or -x flag is required. Usage: python http-get-improved.py -i <input file> | -x <xml file>" +
              COLOURS["end"])
        sys.exit(2)


def xml_file_scanner(xml_file: str):
    print(COLOURS["star"] + " XML file is " + xml_file + COLOURS["end"])
    report = NmapParser.parse_fromfile(xml_file)
    output_dir = input("Enter the directory to save the output files: ")
    print(output_dir)
    output_files = initialize_output_files(output_dir)
    analyze_report(report, output_files)
    close_output_files(output_files)


def txt_file_scanner(target_file: str):
    print(COLOURS["star"] + " Target file is " + target_file + COLOURS["end"])
    output_dir = input("Enter the directory to save the output files: ")
    output_files = initialize_output_files(output_dir)

    with open(target_file, 'r') as file:
        for line in file:
            host, port = line.strip().split(':')
            analyze_service(host, port, output_files)

    print(COLOURS["plus"] + " Finished Testing all hosts! exiting.." + COLOURS["end"])
    close_output_files(output_files)


def analyze_report(report, output_files):
    total_services = 0

    for host in report.hosts:
        for service in host.services:
            if "http" in service.service.lower():
                total_services += 1
                analyze_service(host.address, service.port, output_files)

    if total_services == 0:
        print(COLOURS["plus"] + " No services found" + COLOURS["end"])

    print(COLOURS["plus"] + " Finished Testing all hosts! exiting.." + COLOURS["end"])


def analyze_service(host: str, port: str, output_files: dict):
    try:
        url = f"http://{host}:{port}"
        response = requests.get(url, allow_redirects=False, timeout=5)
        print(COLOURS["star"] + f' Testing host: {host} on port: {port}')
        print(COLOURS["star"] + f' Webserver returned a {response.status_code} status code')

        if response.status_code == 200:
            print(COLOURS["plus"] + ' Web Server is plaintext' + COLOURS["end"])
            output_files["plaintext"].write(f"{host}:{port}\n")
            output_files["log"].write(f"{host}:{port}, {response.status_code}, n\n")
        elif response.status_code in [301, 302, 303, 307, 308]:
            handle_redirect(response, host, port, output_files)
        else:
            log_warning(f' Web server responded with a {response.status_code} and did not specify a redirect', host,
                        port, output_files)

    except requests.exceptions.RequestException as e:
        handle_request_exception(host, port, e, output_files)


def handle_redirect(response, host: str, port: str, output_files: dict):
    if "Location" in response.headers:
        print(COLOURS["star"] + f' Webserver redirects to: {response.headers["Location"]}' + COLOURS["end"])
        redirect_url = response.headers["Location"]

        if "https" in redirect_url:
            print(COLOURS["star"] + f' Following redirect to {redirect_url} for HSTS validation.')
            analyze_https_redirect(host, port, redirect_url, response, output_files)
        else:
            print(COLOURS["plus"] + ' Redirect is plaintext' + COLOURS["end"])
            output_files["plaintext"].write(f"{host}:{port}\n")
            output_files["log"].write(f"{host}:{port}, {response.status_code}, y, {redirect_url}\n")
    else:
        log_warning(f' Web server responded with a {response.status_code} and did not specify a redirect', host, port,
                    output_files)


def analyze_https_redirect(host: str, port: str, redirect_url: str, original_response, output_files: dict):
    try:
        s = requests.get(redirect_url, allow_redirects=True, timeout=5, verify=False)
        hsts_header = s.headers.get('Strict-Transport-Security')

        if hsts_header:
            # header, value = hsts_header.split("=")
            header, value = hsts_header.split(",")[0].split("=")
            max_age = ''.join(char for char in value if char.isdigit())

            if int(max_age) >= 7776000:
                print(COLOURS["minus"] + ' Webserver is Redirecting to https and includes HSTS declaration' + COLOURS[
                    "end"])
                output_files["redirect"].write(f"{host}:{port}\n")
                output_files["log"].write(
                    f"{host}:{port}, {original_response.status_code}, y, {redirect_url}, {header}:{value}\n")
            else:
                log_warning(f' Webserver is Redirecting to https but HSTS max-age value is too low', host, port,
                            output_files)
                output_files["log"].write(
                    f"{host}:{port}, {original_response.status_code}, y, {redirect_url}, {header}:{value}\n")
        else:
            log_warning(f' Webserver utilises a redirect to HTTPS, but HSTS declaration is not present.', host, port,
                        output_files)

    except requests.exceptions.RequestException as e:
        handle_request_exception(host, port, e, output_files)


def log_warning(message: str, host: str, port: str, output_files: dict):
    print(COLOURS["warn"] + message + COLOURS["end"])
    output_files["warnings"].write(f'{COLOURS["warn"]} {message} {host}:{port}\n')
    output_files["log"].write(f"{host}:{port}, Warning\n")


def handle_request_exception(host: str, port: str, exception: Exception, output_files: dict):
    print(COLOURS["warn"] + f' Error occurred while testing {host}:{port}: {exception}' + COLOURS["end"])
    output_files["errorlog"].write(f'{COLOURS["warn"]} Error occurred while testing {host}:{port}: {exception}\n')
    output_files["log"].write(f"{host}:{port}, Error, n\n")


if __name__ == "__main__":
    banner()
    main()
